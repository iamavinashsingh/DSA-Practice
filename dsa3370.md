# 3370. Smallest Number With All Set Bits
You are given a positive number n.

Return the smallest number x greater than or equal to n, such that the binary representation of x contains only set bits

 

Example 1:

Input: n = 5

Output: 7

Explanation:

The binary representation of 7 is "111".

Example 2:

Input: n = 10

Output: 15

Explanation:

The binary representation of 15 is "1111".

Example 3:

Input: n = 3

Output: 3

Explanation:

The binary representation of 3 is "11".

Constraints:

1 <= n <= 1000

---

Tweet 1:
#Day101 of #LearningInPublic ðŸ§ 
Today's @LeetCode POTD â€” â€œSmallest Number With All Set Bitsâ€ ðŸ’¡

Given a number n, find the smallest number x â‰¥ n such that its binary form has all bits set to 1.
Sounds fancy? Letâ€™s break it down in simple words ðŸ‘‡

Tweet 2:
ðŸ‘€ Quick reminder:
Binary numbers are made of 0s and 1s.

When all bits are 1, numbers look like this â¬‡ï¸
1 â†’ 1
3 â†’ 11
7 â†’ 111
15 â†’ 1111

Notice something? Each is of the form (2^a - 1) âœ¨

Tweet 3:
So the idea is simple â€”
ðŸ‘‰ Start from a = 1, keep calculating (2^a - 1)
ðŸ‘‰ Stop when that value becomes â‰¥ n

Thatâ€™s your smallest number with all bits set ðŸ’¯

Itâ€™s basically finding which â€œall 1sâ€ number can cover your n.

Tweet 4:
Letâ€™s visualize ðŸ”

If n = 5 â†’ next â€œall 1sâ€ number is 7 â†’ 111

If n = 10 â†’ next â€œall 1sâ€ number is 15 â†’ 1111

If n = 3 â†’ already 11 â†’ so answer = 3

Clean logic + simple loop âœ…

Tweet 5 (closing):
âœ¨ Intuition: Keep making numbers of the form (2^a - 1)
Stop when itâ€™s not smaller than n.
Thatâ€™s your answer â€” no fancy tricks, just pure logic ðŸ˜„


---

```cpp
class Solution {
public:
    int smallestNumber(int n) {
        int a = 1;
        while (true) {
            int x = pow(2, a) - 1;
            if (x >= n) return x;
            a++;
        }
    }
};

```
