# 2598. Smallest Missing Non-negative Integer After Operations

You are given a 0-indexed integer array nums and an integer value.

In one operation, you can add or subtract value from any element of nums.

For example, if nums = [1,2,3] and value = 2, you can choose to subtract value from nums[0] to make nums = [-1,2,3].
The MEX (minimum excluded) of an array is the smallest missing non-negative integer in it.

For example, the MEX of [-1,2,3] is 0 while the MEX of [1,0,3] is 2.
Return the maximum MEX of nums after applying the mentioned operation any number of times.

 

Example 1:

Input: nums = [1,-10,7,13,6,8], value = 5
Output: 4
Explanation: One can achieve this result by applying the following operations:
- Add value to nums[1] twice to make nums = [1,0,7,13,6,8]
- Subtract value from nums[2] once to make nums = [1,0,2,13,6,8]
- Subtract value from nums[3] twice to make nums = [1,0,2,3,6,8]
The MEX of nums is 4. It can be shown that 4 is the maximum MEX we can achieve.
Example 2:

Input: nums = [1,-10,7,13,6,8], value = 7
Output: 2
Explanation: One can achieve this result by applying the following operation:
- subtract value from nums[2] once to make nums = [1,-10,0,13,6,8]
The MEX of nums is 2. It can be shown that 2 is the maximum MEX we can achieve.
 

Constraints:

1 <= nums.length, value <= 10^5
-109 <= nums[i] <= 10^9

---
#Day88 of #LearningInPublic âœ¨
Today's @LeetCode POTD â†’ 2598. Smallest Missing Non-negative Integer After Operations ðŸ§®

Weâ€™re bending numbers, adding & subtracting like wizards ðŸ§™â€â™‚ï¸â€” all to find the maximum possible MEX ðŸ˜³
Letâ€™s simplify this mystery ðŸ§µðŸ‘‡
#LeetCode #DSA #100DaysOfCode

Tweet 2 (Problem story):
Youâ€™re given an array nums and a number value.

In one move âž• or âž– value to any element.
You can do it as many times as you want! ðŸ˜¯

Goal â†’ After all moves, find the maximum MEX (the smallest non-negative number missing in the array).

Tweet 3 (Example intuition):
nums = [1, -10, 7, 13, 6, 8], value = 5

You can tweak numbers using +5 or -5 until you â€œcoverâ€ as many integers starting from 0 as possible.
Eventually, the array can represent {0,1,2,3} â†’ so MEX = 4 âœ…

Tweet 4 (Key Insight):
The real trick?
ðŸ‘‰ The remainders (mod value) decide everything.

Because adding or subtracting multiples of value never changes the remainder!
So each remainder group can represent one chain of numbers (0, 1, 2, 3â€¦).

Tweet 5 (Simplifying it):
Think like this ðŸ‘‡
Each remainder bucket (0, 1, 2, â€¦ value-1) has some elements.
Each time you can use one element from the correct remainder to represent the next integer.

Once a bucket runs out â†’ your MEX stops there âš¡

Tweet 6 (How it unfolds):
We start counting from 0 â†’
If remainder of (0 mod value) exists â†’ âœ…
Then next (1 mod value) â†’ âœ…
Keep going until one remainder group is empty.
Thatâ€™s where your MEX ends.

Simple, modular, elegant âœ¨

Tweet 7 (Lesson):
This problem isnâ€™t about brute force â€”
Itâ€™s about spotting the hidden pattern in modular arithmetic ðŸ”¢
Once you see the â€œremainder bucketsâ€, the whole chaos becomes math poetry ðŸ˜Œ

Tweet 8 (Engagement):
Do you also love when a scary-looking DSA problem turns out to be pure logic disguised in numbers? ðŸ˜†

That moment when you go â€”
â€œOh waitâ€¦ itâ€™s just mod math!â€ ðŸ§ ðŸ’¥

Tweet 9 (Closing):
Thatâ€™s todayâ€™s @LeetCode POTD ðŸ§®
ðŸ‘‰ 2598. Smallest Missing Non-negative Integer After Operations
A reminder that sometimesâ€¦
seeing patterns > solving equations ðŸ’«

---
```cpp
class Solution {
public:
	int findSmallestInteger(vector<int>& nums, int v) {
		long long n = nums.size(), x, res = 0;
		vector<int> rem(v, 0);
		for (int i = 0; i < n; i++) {
			x = ((nums[i] % v) + v) % v;
			rem[x]++;
		}

		while (rem[res % v]--) res++;
		return res;
	}
};
```
