# 3625. Count Number of Trapezoids II
You are given a 2D integer array points where points[i] = [xi, yi] represents the coordinates of the ith point on the Cartesian plane.

Return the number of unique trapezoids that can be formed by choosing any four distinct points from points.

A trapezoid is a convex quadrilateral with at least one pair of parallel sides. Two lines are parallel if and only if they have the same slope.

 

Example 1:

Input: points = [[-3,2],[3,0],[2,3],[3,2],[2,-3]]

Output: 2

Explanation:



There are two distinct ways to pick four points that form a trapezoid:

The points [-3,2], [2,3], [3,2], [2,-3] form one trapezoid.
The points [2,3], [3,2], [3,0], [2,-3] form another trapezoid.
Example 2:

Input: points = [[0,0],[1,0],[0,1],[2,1]]

Output: 1

Explanation:



There is only one trapezoid which can be formed.

 

Constraints:

4 <= points.length <= 500
â€“1000 <= xi, yi <= 1000
All points are pairwise distinct.

---

```cpp
class Solution {
public:
    int hashSlope(int a,int b){
        return a*4003+b;
    }

    int countTrapezoids(vector<vector<int>>& points) {
        int n= points.size();

        unordered_map<int,unordered_map<int,int>> m;
        unordered_map<int,unordered_map<int,map<int,int>>> m2;

        for(int i=0;i<n;i++){
            int x0=points[i][0], y0=points[i][1];
            for(int j=i+1;j<n;j++){
                int x1=points[j][0], y1=points[j][1];

                int a = y1-y0, b = x0-x1;
                int len = a*a + b*b;

                if(a<0) a=-a, b=-b;

                if(a*b==0){
                    if(a==0) b=1;
                    else a=1;
                } else {
                    int g = gcd(abs(a),abs(b));
                    a/=g; b/=g;
                }

                int c = a*x0 + b*y0;
                int h = hashSlope(a,b);

                m[h][c]++;
                m2[h][c][len]++;
            }
        }

        int total = 0;
        for(auto &p : m){
            int prev = 0;
            for(auto &q : p.second){
                total += q.second * prev;
                prev += q.second;
            }
        }

        int same = 0;
        for(auto &p : m2){
            map<int,int> prev;
            for(auto &q : p.second){
                for(auto &r : q.second){
                    same += r.second * prev[r.first];
                    prev[r.first] += r.second;
                }
            }
        }

        return total - same/2;
    }
};


```
