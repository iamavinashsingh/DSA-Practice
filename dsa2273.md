# 2273. Find Resultant Array After Removing Anagrams
You are given a 0-indexed string array words, where words[i] consists of lowercase English letters.

In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words. Keep performing this operation as long as you can select an index that satisfies the conditions.

Return words after performing all operations. It can be shown that selecting the indices for each operation in any arbitrary order will lead to the same result.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, "dacb" is an anagram of "abdc".

 

Example 1:

Input: words = ["abba","baba","bbaa","cd","cd"]
Output: ["abba","cd"]
Explanation:
One of the ways we can obtain the resultant array is by using the following operations:
- Since words[2] = "bbaa" and words[1] = "baba" are anagrams, we choose index 2 and delete words[2].
  Now words = ["abba","baba","cd","cd"].
- Since words[1] = "baba" and words[0] = "abba" are anagrams, we choose index 1 and delete words[1].
  Now words = ["abba","cd","cd"].
- Since words[2] = "cd" and words[1] = "cd" are anagrams, we choose index 2 and delete words[2].
  Now words = ["abba","cd"].
We can no longer perform any operations, so ["abba","cd"] is the final answer.
Example 2:

Input: words = ["a","b","c","d","e"]
Output: ["a","b","c","d","e"]
Explanation:
No two adjacent strings in words are anagrams of each other, so no operations are performed.
 

Constraints:

1 <= words.length <= 100
1 <= words[i].length <= 10
words[i] consists of lowercase English letters.

---

Tweet 1 (Hook):
#Day85 of #LearningInPublic
Today's @LeetCode POTD: 2273. Find Resultant Array After Removing Anagrams ðŸ§©

Itâ€™s a cute little string problem â€” simple yet sneaky! Letâ€™s understand how to â€œde-anagramâ€ our array ðŸ‘‡
#LeetCode #DSA #100DaysOfCode

Tweet 2 (Story setup):
Imagine you have a list of words.
If two adjacent words are anagrams (same letters, jumbled order), you delete the later one.
Keep doing it till no more anagrams are side-by-side ðŸ˜…

Your job? Return the final list that survives ðŸ§ 

Tweet 3 (Example):
words = ["abba","baba","bbaa","cd","cd"]

Step by step:

"abba" & "baba" â†’ anagrams â†’ remove "baba"

"abba" & "bbaa" â†’ anagrams â†’ remove "bbaa"

"cd" & "cd" â†’ anagrams â†’ remove one
âœ… Final = ["abba","cd"]

Tweet 4 (Key Idea):
We donâ€™t care how anagrams are formed â€” just whether two neighbors have the same letters ðŸ” 

So for each word, think of its character frequency or sorted version.
If the current wordâ€™s pattern = previous wordâ€™s pattern â†’ skip it.
Else â†’ keep it âœ¨

Tweet 5 (Why this works):
Because the operation only depends on adjacent anagrams, not global ones.
Once two consecutive words differ in their letter set, they both safely stay ðŸ’ª

No matter which order you remove them, the result stays the same ðŸ”„

Tweet 6 (Concept takeaway):
ðŸ‘‰ Always compare the structure (not order) of words
ðŸ‘‰ Think of anagrams as â€œsame content, different arrangementâ€
ðŸ‘‰ This is basically pattern deduplication for strings ðŸŽ¯

Tweet 7 (Engagement):
Fun question ðŸ¤”ðŸ‘‡
If you had to â€œde-anagramâ€ your playlist â€” removing songs with the same tune but remixed order â€” which song would survive? ðŸŽ¶ðŸ˜…

Tweet 8 (Closing):
Thatâ€™s todayâ€™s @LeetCode POTD wrapped ðŸŽ€
â€œFind Resultant Array After Removing Anagramsâ€
Simple, elegant, & surprisingly logical ðŸ’¡

Tomorrow â†’ another problem, another insight

---

```cpp
class Solution {
public:
    vector<string> removeAnagrams(vector<string>& words) {
        vector<unordered_map<char, int>> freq(words.size());

        for (int i = 0; i < words.size(); i++) {
            for (char ch : words[i]) freq[i][ch]++;
        }

        vector<string> ans;
        ans.push_back(words[0]);
        for (int i = 1; i < words.size(); i++) {
            if (freq[i] != freq[i - 1]) ans.push_back(words[i]);
        }
        return ans;
    }
};

```
