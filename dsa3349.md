# 3349. Adjacent Increasing Subarrays Detection I
Given an array nums of n integers and an integer k, determine whether there exist two adjacent subarrays of length k such that both subarrays are strictly increasing. Specifically, check if there are two subarrays starting at indices a and b (a < b), where:

Both subarrays nums[a..a + k - 1] and nums[b..b + k - 1] are strictly increasing.
The subarrays must be adjacent, meaning b = a + k.
Return true if it is possible to find two such subarrays, and false otherwise.

 

Example 1:

Input: nums = [2,5,7,8,9,2,3,4,3,1], k = 3

Output: true

Explanation:

The subarray starting at index 2 is [7, 8, 9], which is strictly increasing.
The subarray starting at index 5 is [2, 3, 4], which is also strictly increasing.
These two subarrays are adjacent, so the result is true.
Example 2:

Input: nums = [1,2,3,4,4,4,4,5,6,7], k = 5

Output: false

 

Constraints:

2 <= nums.length <= 100
1 < 2 * k <= nums.length
-1000 <= nums[i] <= 1000

---

Todayâ€™s @LeetCode POTD is 3349: Adjacent Increasing Subarrays Detection I ğŸ“ˆğŸ’«

Weâ€™re finding two strictly increasing subarrays that sit side by side like twins ğŸ«±ğŸ«²
Letâ€™s decode it together ğŸ§µğŸ‘‡
#LeetCode #DSA #100DaysOfCode

Tweet 2 (Problem story):
Given an array nums and a number k,
can we find two back-to-back subarrays of length k,
where both are strictly increasing?

Itâ€™s like spotting two smooth â€œascending slopesâ€ right next to each other on a mountain ğŸ”ï¸ğŸ“Š

Tweet 3 (Example time):
nums = [2,5,7,8,9,2,3,4,3,1], k = 3

ğŸ‘‰ [7,8,9] is increasing
ğŸ‘‰ [2,3,4] (right after it) is also increasing
Two perfect slopes side-by-side âœ…
So answer = true âœ¨

Tweet 4 (Core Idea):
We donâ€™t need to actually cut subarrays â€”
we just need to track consecutive increasing streaks.
When a streak breaks, start counting again ğŸ§®

If you ever see two consecutive streaks long enough (â‰¥ k each) â†’ boom ğŸ’¥ found it!

Tweet 5 (Thinking behind it):
Every time numbers go up â†’ increase count ğŸ“ˆ
When they stop â†’ store previous streak, start new
If both previous and current streaks are at least length k â†’ condition satisfied âœ…

Thatâ€™s the entire magic â€” efficient, clean, and elegant ğŸª„

Tweet 6 (Lesson):
The trick wasnâ€™t about arrays â€”
it was about detecting patterns in data flows ğŸ”
Once you see â€œincreasing streaksâ€ as segments,
the problem turns from hard â†’ beautiful â¤ï¸

Tweet 7 (Engagement):
Ever noticed how many DSA problems are really just about pattern recognition in disguise? ğŸ¤”
Once your brain trains to see patterns â†’ you level up as a problem solver âš¡

Tweet 8 (Closing):
So thatâ€™s todayâ€™s @LeetCode POTD âœ¨
3349 â€” Adjacent Increasing Subarrays ğŸ§©
Moral: Track streaks. Spot patterns. Keep climbing. ğŸ“ˆğŸ”ï¸

---

```cpp
class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int prev = 0, increaseCount = 1;

        for(int i=1; i<nums.size(); i++) {
            if(nums[i-1] < nums[i]) increaseCount++;
            else {
                prev = increaseCount;
                increaseCount = 1;
            }

            if(increaseCount / 2 >= k || prev / 2 >= k
                || min(prev, increaseCount) >= k) return true;
        }
        return false;
    }
};

```
