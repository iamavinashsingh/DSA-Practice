# 1625. Lexicographically Smallest String After Applying Operations
You are given a string s of even length consisting of digits from 0 to 9, and two integers a and b.

You can apply either of the following two operations any number of times and in any order on s:

Add a to all odd indices of s (0-indexed). Digits post 9 are cycled back to 0. For example, if s = "3456" and a = 5, s becomes "3951".
Rotate s to the right by b positions. For example, if s = "3456" and b = 1, s becomes "6345".
Return the lexicographically smallest string you can obtain by applying the above operations any number of times on s.

A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, "0158" is lexicographically smaller than "0190" because the first position they differ is at the third letter, and '5' comes before '9'.

 

Example 1:

Input: s = "5525", a = 9, b = 2
Output: "2050"
Explanation: We can apply the following operations:
Start:  "5525"
Rotate: "2555"
Add:    "2454"
Add:    "2353"
Rotate: "5323"
Add:    "5222"
Add:    "5121"
Rotate: "2151"
Add:    "2050"â€‹â€‹â€‹â€‹â€‹
There is no way to obtain a string that is lexicographically smaller than "2050".
Example 2:

Input: s = "74", a = 5, b = 1
Output: "24"
Explanation: We can apply the following operations:
Start:  "74"
Rotate: "47"
â€‹â€‹â€‹â€‹â€‹â€‹â€‹Add:    "42"
â€‹â€‹â€‹â€‹â€‹â€‹â€‹Rotate: "24"â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹
There is no way to obtain a string that is lexicographically smaller than "24".
Example 3:

Input: s = "0011", a = 4, b = 2
Output: "0011"
Explanation: There are no sequence of operations that will give us a lexicographically smaller string than "0011".
 

Constraints:

2 <= s.length <= 100
s.length is even.
s consists of digits from 0 to 9 only.
1 <= a <= 9
1 <= b <= s.length - 1
 
---
Today's @LeetCode POTD: "Lexicographically Smallest String After Applying Operations" (1625)

A deceptively tricky problem about string transformations ðŸ”âœ¨
Letâ€™s simplify it ðŸ‘‡

ðŸ’­ Youâ€™re given a string s made of digits (even length), and two operations you can use any number of times:
1ï¸âƒ£ Add a â†’ Add a to all digits at odd indices (like 1,3,5,...) cyclically (9â†’0).
2ï¸âƒ£ Rotate by b â†’ Move the last b digits to the front.

Your goal? ðŸŽ¯
ðŸ‘‰ Find the smallest possible string (lexicographically) after performing these operations in any order, any number of times!

ðŸ§  The trick here:
These operations can be done infinitely, but many of them repeat after a few cycles.
So instead of brute force, we can explore all unique strings we can reach!

ðŸ” How we think:
1ï¸âƒ£ Start with the original string.
2ï¸âƒ£ Try both operations:

Add to odd indices.

Rotate by b.
3ï¸âƒ£ Store all new strings you generate and keep exploring them (like BFS in graphs).
4ï¸âƒ£ Keep track of the smallest string seen so far.

ðŸ’¡ Why BFS?
Because every operation leads to new possible states (like exploring all connected nodes).
We keep exploring until weâ€™ve seen all possible transformations ðŸ”

âœ¨ Intuition Recap:
Each operation gives a â€œpathâ€ to transform the string.
By exploring every unique result once, we ensure we donâ€™t miss the smallest one.

Itâ€™s like searching for the â€œmost sortedâ€ version of the string hidden behind rotations and digit tweaks ðŸ§©

ðŸ“Š Complexity Insight:
âœ… Limited unique states (since digits & rotations repeat after some cycles).
âœ… Efficient BFS ensures we visit each state once.
âœ… Guaranteed termination.

ðŸš€ Takeaway:
This problem isnâ€™t about math â€” itâ€™s about state exploration and pattern observation.
Youâ€™re not just rotating or adding â€” youâ€™re navigating through all possible â€œworldsâ€ of the string! ðŸŒâœ¨

ðŸ’¬ What I learned today:
Even a simple string with two small operations can create a huge but finite search space â€” mastering BFS here gives a deeper appreciation for problem modeling â¤ï¸


---
```cpp
class Solution {
private:
      string ro(string &s,int b){
        int n=s.size();
        string pre=s.substr(0,b);
        string suf=s.substr(b,n-b);
        return suf+pre;
      }    
public:
    string findLexSmallestString(string s, int a, int b) {
        int n=s.size();
        queue<string>q;
        q.push(s);
        unordered_map<string,int>mp;
        mp[s]=1;
        string mini=s;
        while(!q.empty()){
            string node=q.front();
            q.pop();
            mini=min(mini,node);
            string rotate=ro(node,b);
            if(mp.find(rotate)==mp.end()){
              q.push(rotate);
              mp[rotate]=1; 
            }
            string addNode=node;
            for(int i=1;i<n;i+=2){
                int val=node[i]-'0';
                val=(val+a)%10;
                addNode[i]=val+'0';
            }
            if(mp.find(addNode)==mp.end()){
                q.push(addNode);
                mp[addNode]=0;
            }
                    
        }
        return mini;
    }
};

```
