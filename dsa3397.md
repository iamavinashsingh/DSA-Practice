# 3397. Maximum Number of Distinct Elements After Operations
You are given an integer array nums and an integer k.

You are allowed to perform the following operation on each element of the array at most once:

Add an integer in the range [-k, k] to the element.
Return the maximum possible number of distinct elements in nums after performing the operations.

 

Example 1:

Input: nums = [1,2,2,3,3,4], k = 2

Output: 6

Explanation:

nums changes to [-1, 0, 1, 2, 3, 4] after performing operations on the first four elements.

Example 2:

Input: nums = [4,4,4,4], k = 1

Output: 3

Explanation:

By adding -1 to nums[0] and 1 to nums[1], nums changes to [3, 5, 4, 4].

 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 10^9
0 <= k <= 10^9

---


You can tweak each element by Â±k just once â€” how can you make your array as distinct as possible? ðŸ¤”
Letâ€™s break it down ðŸ§µðŸ‘‡
#LeetCode #DSA #100DaysOfCode

Tweet 2 (Problem story):
Youâ€™re given an array nums and a number k.
For every element, you can add or subtract up to k (or do nothing).

Goal: make as many numbers as possible unique ðŸ”¢ðŸ’«

Tweet 3 (Example time):
nums = [1,2,2,3,3,4], k = 2

ðŸ‘‰ After tweaking, we can make it like
[-1, 0, 1, 2, 3, 4]
âœ¨ 6 distinct elements achieved!

Tweet 4 (Intuition):
When duplicates exist, we can spread them apart using Â±k.
But we must be smart â€” if we move them randomly, overlaps may happen again ðŸ˜…

We need a systematic way to choose where each element lands ðŸŽ¯

Tweet 5 (Core Idea):
Sort the array first ðŸ§®
Then go left â†’ right, and for each number:

Pick the smallest possible value within its allowed range thatâ€™s still bigger than the previous number.

Itâ€™s like filling boxes in order â€” no gaps wasted, no overlap allowed ðŸ“¦

Tweet 6 (Why it works):
By always choosing the next smallest valid number,
we maximize space for future elements â€”
leading to maximum distinct count! ðŸš€

Simple, greedy, elegant ðŸ’¡

Tweet 7 (Lesson):
Sometimes optimization isnâ€™t about big jumps,
itâ€™s about tiny smart moves in the right order ðŸ‘£

Greedy + Sorting = underrated combo in DSA ðŸ’ª

Tweet 8 (Engagement):
Would you rather:
ðŸ‘‰ Go big with one operation
or
ðŸ‘‰ Go step-by-step and stay optimal? ðŸ˜

Because todayâ€™s problem proves â€” consistency wins


---

```cpp
class Solution {
public:
    int maxDistinctElements(vector<int>& nums, int k) {
        if (nums.size() <= k) {
            return nums.size();
        }
        
        sort(nums.begin(), nums.end());
        long long current = LLONG_MIN;
        int res = 0;
        
        for (int num : nums) {
            long long target = max(current + 1, (long long)num - k);
            
            if (target <= num + k) {
                current = target;
                res++;
            } else {
                current = max(current, (long long)num);
            }
        }
        
        return res;
    }
};
```
 
