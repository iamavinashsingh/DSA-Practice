# 1526. Minimum Number of Increments on Subarrays to Form a Target Array
You are given an integer array target. You have an integer array initial of the same size as target with all elements initially zeros.

In one operation you can choose any subarray from initial and increment each value by one.

Return the minimum number of operations to form a target array from initial.

The test cases are generated so that the answer fits in a 32-bit integer.

 

Example 1:

Input: target = [1,2,3,2,1]
Output: 3
Explanation: We need at least 3 operations to form the target array from the initial array.
[0,0,0,0,0] increment 1 from index 0 to 4 (inclusive).
[1,1,1,1,1] increment 1 from index 1 to 3 (inclusive).
[1,2,2,2,1] increment 1 at index 2.
[1,2,3,2,1] target array is formed.
Example 2:

Input: target = [3,1,1,2]
Output: 4
Explanation: [0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2]
Example 3:

Input: target = [3,1,5,4,2]
Output: 7
Explanation: [0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] -> [3,1,1,1,1] -> [3,1,2,2,2] -> [3,1,3,3,2] -> [3,1,4,4,2] -> [3,1,5,4,2].
 

Constraints:

1 <= target.length <= 10^5
1 <= target[i] <= 10^5

---
Tweet 1:
#Day102 of #LearningInPublic ğŸ§ 
Today's @LeetCode POTD â€” â€œMinimum Number of Increments on Subarrays to Form a Target Arrayâ€ ğŸ’¡

We start from all zeros â¡ï¸ and want to reach the given target array using the fewest â€œincrement subarrayâ€ operations.
Sounds tricky? Letâ€™s decode it ğŸ‘‡

Tweet 2:
Imagine you have an array of zeros like:
[0,0,0,0,0]
and you need to make it [1,2,3,2,1] ğŸ˜¯

You can choose any continuous subarray and increase every number in it by 1 in one move.
The goal â†’ reach target using the least such moves!

Tweet 3:
Hereâ€™s the key insight ğŸ§ âœ¨

ğŸ‘‰ Every time the value increases compared to the previous element,
you need that many new increments to reach the new height.

ğŸ‘‰ But when the value drops or stays the same, you donâ€™t need extra moves â€” because those were already done before.

Tweet 4:
Letâ€™s visualize ğŸ‘‡

For [1,2,3,2,1]
Start with first value â†’ 1 move needed.
Then:
2â†’3 (+1)
3â†’3 (+0)
3â†’2 (+0)
2â†’1 (+0)

So total = 1 + (2-1) + (3-2) = 3 moves âœ…

Tweet 5:
In short âœ¨
ğŸ”¹ Add target[0] (the first climb).
ğŸ”¹ Then, for every next element,
add only the positive increase from the previous one.

Thatâ€™s it!
Simple, linear, and elegant ğŸ’«

---

```cpp
class Solution {
public:
    int minNumberOperations(vector<int>& target) {
        int n = target.size();
        if (n == 0) return 0;

        int res = target[0];
        for (int i = 1; i < n; ++i)
            res += max(0, target[i] - target[i - 1]);
        return res;
    }
};

```
