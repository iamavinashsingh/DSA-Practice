# 3100. Water Bottles II

You are given two integers numBottles and numExchange.

numBottles represents the number of full water bottles that you initially have. In one operation, you can perform one of the following operations:

Drink any number of full water bottles turning them into empty bottles.
Exchange numExchange empty bottles with one full water bottle. Then, increase numExchange by one.
Note that you cannot exchange multiple batches of empty bottles for the same value of numExchange. For example, if numBottles == 3 and numExchange == 1, you cannot exchange 3 empty water bottles for 3 full bottles.

Return the maximum number of water bottles you can drink.

 

Example 1:


Input: numBottles = 13, numExchange = 6
Output: 15
Explanation: The table above shows the number of full water bottles, empty water bottles, the value of numExchange, and the number of bottles drunk.
Example 2:


Input: numBottles = 10, numExchange = 3
Output: 13
Explanation: The table above shows the number of full water bottles, empty water bottles, the value of numExchange, and the number of bottles drunk.
 

Constraints:

1 <= numBottles <= 100 
1 <= numExchange <= 100

---

1/
3100. Water Bottles II ðŸ’§
This LeetCode problem looks simple at firstâ€¦ but thereâ€™s a sneaky twist ðŸ‘€.
Let me break it down in plain English â€” no code, just logic. #LeetCode #DSA

2/
ðŸ‘‰ You start with some full bottles.
ðŸ‘‰ When you drink, you get empty bottles.
ðŸ‘‰ You can exchange a fixed number of empty bottles for 1 new full bottle.
ðŸ‘‰ But hereâ€™s the catch: every time you exchange, the cost increases by +1 ðŸ˜®.

3/
So the real question is:
â€œHow many bottles can you drink before you canâ€™t exchange anymore?â€ ðŸ¥¤

Sounds like a brain teaser, right? Letâ€™s play it outâ€¦

4/
Imagine you have 13 bottles and exchange rate = 6.

Drink 13 â†’ 13 empties

Trade 6 empties â†’ +1 full (now exchange = 7)

Drink that 1 â†’ more empties

Repeat until you canâ€™t afford the new exchange rate.

5/
Whatâ€™s happening under the hood?

âœ… We always keep track of 2 things:

Total bottles drunk (our answer ðŸ“ˆ)

Current empty bottles (our â€œcurrencyâ€ ðŸ’°)

At every step:

Spend empties to get 1 full

Drink it â†’ empties go up again

Exchange cost goes up by +1

6/
Notice the tradeoff:
The longer you go, the harder it gets to exchange.
At some point, the empties arenâ€™t enough to meet the rising cost. Thatâ€™s where you stop. ðŸš«

7/
Key insight ðŸ’¡:
Itâ€™s just a simulation problem.
Drink â†’ Exchange â†’ Cost increases â†’ Repeat.
No fancy DP or math trick needed, just careful bookkeeping.

8/
Final takeaway âœ¨:
Even simple-looking problems hide layers when a small twist (like increasing cost) is added.
Thatâ€™s why practicing these â€œstory-likeâ€ problems builds intuition fast ðŸš€

---

```cpp
class Solution {
public:
    int maxBottlesDrunk(int numBottles, int numExchange) {
        int res = numBottles; 
        int emp = numBottles;
        while (emp >= numExchange) {
            emp -= numExchange;
            res++;
            emp++;
            numExchange++;
        }
        return res;
    }
};
```
