# 3562. Maximum Profit from Trading Stocks with Discounts
You are given an integer n, representing the number of employees in a company. Each employee is assigned a unique ID from 1 to n, and employee 1 is the CEO. You are given two 1-based integer arrays, present and future, each of length n, where:

present[i] represents the current price at which the ith employee can buy a stock today.
future[i] represents the expected price at which the ith employee can sell the stock tomorrow.
The company's hierarchy is represented by a 2D integer array hierarchy, where hierarchy[i] = [ui, vi] means that employee ui is the direct boss of employee vi.

Additionally, you have an integer budget representing the total funds available for investment.

However, the company has a discount policy: if an employee's direct boss purchases their own stock, then the employee can buy their stock at half the original price (floor(present[v] / 2)).

Return the maximum profit that can be achieved without exceeding the given budget.

Note:

You may buy each stock at most once.
You cannot use any profit earned from future stock prices to fund additional investments and must buy only from budget.
 

Example 1:

Input: n = 2, present = [1,2], future = [4,3], hierarchy = [[1,2]], budget = 3

Output: 5

Explanation:



Employee 1 buys the stock at price 1 and earns a profit of 4 - 1 = 3.
Since Employee 1 is the direct boss of Employee 2, Employee 2 gets a discounted price of floor(2 / 2) = 1.
Employee 2 buys the stock at price 1 and earns a profit of 3 - 1 = 2.
The total buying cost is 1 + 1 = 2 <= budget. Thus, the maximum total profit achieved is 3 + 2 = 5.
Example 2:

Input: n = 2, present = [3,4], future = [5,8], hierarchy = [[1,2]], budget = 4

Output: 4

Explanation:



Employee 2 buys the stock at price 4 and earns a profit of 8 - 4 = 4.
Since both employees cannot buy together, the maximum profit is 4.
Example 3:

Input: n = 3, present = [4,6,8], future = [7,9,11], hierarchy = [[1,2],[1,3]], budget = 10

Output: 10

Explanation:



Employee 1 buys the stock at price 4 and earns a profit of 7 - 4 = 3.
Employee 3 would get a discounted price of floor(8 / 2) = 4 and earns a profit of 11 - 4 = 7.
Employee 1 and Employee 3 buy their stocks at a total cost of 4 + 4 = 8 <= budget. Thus, the maximum total profit achieved is 3 + 7 = 10.
Example 4:

Input: n = 3, present = [5,2,3], future = [8,5,6], hierarchy = [[1,2],[2,3]], budget = 7

Output: 12

Explanation:



Employee 1 buys the stock at price 5 and earns a profit of 8 - 5 = 3.
Employee 2 would get a discounted price of floor(2 / 2) = 1 and earns a profit of 5 - 1 = 4.
Employee 3 would get a discounted price of floor(3 / 2) = 1 and earns a profit of 6 - 1 = 5.
The total cost becomes 5 + 1 + 1 = 7 <= budget. Thus, the maximum total profit achieved is 3 + 4 + 5 = 12.
 

Constraints:

- 1 <= n <= 160
- present.length, future.length == n
- 1 <= present[i], future[i] <= 50
- hierarchy.length == n - 1
- hierarchy[i] == [ui, vi]
- 1 <= ui, vi <= n
- ui != vi
- 1 <= budget <= 160
- There are no duplicate edges.
- Employee 1 is the direct or indirect boss of every employee.
- The input graph hierarchy is guaranteed to have no cycles.

---


```cpp
class Solution {
public:
    int B;
    vector<int> merge(const vector<int>& dp1, const vector<int>& dp2) {
        vector<int> next(B + 1, -1e9);
        for (int i = 0; i <= B; i++) {
            if (dp1[i] < 0) continue; 
            for (int j = 0; i + j <= B; j++) {
                if (dp2[j] < 0) continue;
                next[i + j] = max(next[i + j], dp1[i] + dp2[j]);
            }
        }
        return next;
    }
    
    void dfs(int u, const vector<vector<int>>& tree, 
             const vector<int>& present, const vector<int>& future, 
             vector<vector<vector<int>>>& dp) {
        
        vector<int> skipBranch(B + 1, -1e9); 
        vector<int> buyBranch(B + 1, -1e9);  
        skipBranch[0] = buyBranch[0] = 0; 
        
        for (int v : tree[u]) {
            dfs(v, tree, present, future, dp);
            skipBranch = merge(skipBranch, dp[v][0]);
            buyBranch = merge(buyBranch, dp[v][1]);   
        }
        

        for (int parentBought = 0; parentBought <= 1; parentBought++) {
            int price = parentBought ? present[u] / 2 : present[u];
            int profit = future[u] - price;
            
           
            vector<int> currentDP = skipBranch;
            

            if (price <= B) {
                for (int b = 0; b <= B - price; b++) {
                    if (buyBranch[b] > -1e9) {
                        currentDP[b + price] = max(currentDP[b + price], 
                                                   buyBranch[b] + profit);
                    }
                }
            }
            dp[u][parentBought] = currentDP;
        }
    }
    
    int maxProfit(int n, vector<int>& present, vector<int>& future, 
                  vector<vector<int>>& hierarchy, int budget) {
        B = budget;
        

        vector<vector<int>> tree(n);
        for (auto& edge : hierarchy) {
            tree[edge[0] - 1].push_back(edge[1] - 1);
        }
        
      
  
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(2));
        
        dfs(0, tree, present, future, dp);
        
      
        int ans = 0;
        for (int b = 0; b <= B; b++) {
            ans = max(ans, dp[0][0][b]);
        }
        return ans;
    }
};

```
