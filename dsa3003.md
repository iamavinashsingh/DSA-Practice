# 3003. Maximize the Number of Partitions After Operations
You are given a string s and an integer k.

First, you are allowed to change at most one index in s to another lowercase English letter.

After that, do the following partitioning operation until s is empty:

Choose the longest prefix of s containing at most k distinct characters.
Delete the prefix from s and increase the number of partitions by one. The remaining characters (if any) in s maintain their initial order.
Return an integer denoting the maximum number of resulting partitions after the operations by optimally choosing at most one index to change.

 

Example 1:

Input: s = "accca", k = 2

Output: 3

Explanation:

The optimal way is to change s[2] to something other than a and c, for example, b. then it becomes "acbca".

Then we perform the operations:

The longest prefix containing at most 2 distinct characters is "ac", we remove it and s becomes "bca".
Now The longest prefix containing at most 2 distinct characters is "bc", so we remove it and s becomes "a".
Finally, we remove "a" and s becomes empty, so the procedure ends.
Doing the operations, the string is divided into 3 partitions, so the answer is 3.

Example 2:

Input: s = "aabaab", k = 3

Output: 1

Explanation:

Initially s contains 2 distinct characters, so whichever character we change, it will contain at most 3 distinct characters, so the longest prefix with at most 3 distinct characters would always be all of it, therefore the answer is 1.

Example 3:

Input: s = "xxyz", k = 1

Output: 4

Explanation:

The optimal way is to change s[0] or s[1] to something other than characters in s, for example, to change s[0] to w.

Then s becomes "wxyz", which consists of 4 distinct characters, so as k is 1, it will divide into 4 partitions.

 

Constraints:

1 <= s.length <= 104
s consists only of lowercase English letters.
1 <= k <= 26

---

Tweet 1 (Hook):
#Day89 of #LearningInPublic
Todayâ€™s @LeetCode POTD is 3003: Maximize the Number of Partitions After Operations âœ¨

Itâ€™s a mix of strings + strategic changes + partitioning ðŸª„
Letâ€™s break it down in the easiest way ðŸ§µðŸ‘‡
#LeetCode #DSA #100DaysOfCode

Tweet 2 (Problem story):
You have a string s and a number k.

Operations:

You can change at most one character in s.

Then repeatedly: take the longest prefix with at most k distinct letters â†’ remove it â†’ count as 1 partition.
Goal: maximize total partitions ðŸŽ¯

Tweet 3 (Analogy):
Think of it like cutting a cake ðŸ°:

Each slice can have at most k flavors

Youâ€™re allowed one magic swap to change a flavor

How can you maximize the number of slices? ðŸ¤”

Tweet 4 (Example time):
s = "accca", k = 2

Change s[2] to 'b' â†’ "acbca"

Partitions: "ac" | "bc" | "a" â†’ 3 slices âœ…

Without change â†’ only 2 slices.
One smart change makes a big difference! ðŸ’¡

Tweet 5 (Core Idea):

Track distinct characters in the current prefix

If adding a new character exceeds k â†’ start a new partition

You get one chance to change a character to increase partitions

Use it optimally where it breaks the flow ðŸª„

Tweet 6 (Why it works):
Even a single character change can break a long block into multiple partitions

Makes partitions shorter, increasing total count

Strategy = find the best character to â€œunlockâ€ new partitions ðŸ”‘

Tweet 7 (Lesson + Engagement):
DSA here = pattern + planning:

Observe how new letters affect partitions

Use your one magic move wisely âœ¨

Q: Have you ever solved a problem where just one small change maximized the outcome? ðŸ˜Ž

Tweet 8 (Closing):
Thatâ€™s todayâ€™s @LeetCode POTD: String + Partitions magic ðŸª„
Takeaway â†’ small tweaks + smart tracking = big impact

---
```cpp
class Solution {
public:
    unordered_map<long long, int> memo;

    int dfs(int index, string& s, int charMask, bool canChange, int k) {
        if (index == (int)s.size()) return 0;

        long long key = ((long long)index << 27) | ((long long)charMask << 1) | (canChange ? 1LL : 0LL);
        if (memo.count(key)) return memo[key];

        int currentBit = 1 << (s[index] - 'a');
        int updatedMask = charMask | currentBit;
        int maxPartitions;

        // Keep current character
        if (__builtin_popcount(updatedMask) > k)
            maxPartitions = 1 + dfs(index + 1, s, currentBit, canChange, k);
        else
            maxPartitions = dfs(index + 1, s, updatedMask, canChange, k);

        // Try changing this character to any letter (if allowed)
        if (canChange) {
            for (int c = 0; c < 26; ++c) {
                int newBit = 1 << c;
                int newMask = charMask | newBit;
                int partitions;
                if (__builtin_popcount(newMask) > k)
                    partitions = 1 + dfs(index + 1, s, newBit, false, k);
                else
                    partitions = dfs(index + 1, s, newMask, false, k);
                maxPartitions = max(maxPartitions, partitions);
            }
        }

        return memo[key] = maxPartitions;
    }

    int maxPartitionsAfterOperations(string s, int k) {
        return 1 + dfs(0, s, 0, true, k);
    }
};
```
