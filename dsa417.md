# 417. Pacific Atlantic Water Flow
There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.

The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).

The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.

Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.

 

Example 1:


Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
Explanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:
[0,4]: [0,4] -> Pacific Ocean 
       [0,4] -> Atlantic Ocean
[1,3]: [1,3] -> [0,3] -> Pacific Ocean 
       [1,3] -> [1,4] -> Atlantic Ocean
[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean 
       [1,4] -> Atlantic Ocean
[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean 
       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean
[3,0]: [3,0] -> Pacific Ocean 
       [3,0] -> [4,0] -> Atlantic Ocean
[3,1]: [3,1] -> [3,0] -> Pacific Ocean 
       [3,1] -> [4,1] -> Atlantic Ocean
[4,0]: [4,0] -> Pacific Ocean 
       [4,0] -> Atlantic Ocean
Note that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.
Example 2:

Input: heights = [[1]]
Output: [[0,0]]
Explanation: The water can flow from the only cell to the Pacific and Atlantic oceans.
 

Constraints:

m == heights.length
n == heights[r].length
1 <= m, n <= 200
0 <= heights[r][c] <= 10^5

---
Tweet 1 (Hook):
ðŸŒŠ Imagine rain falling on a mountain islandâ€¦
Some water flows into the Pacific, some into the Atlantic.
But hereâ€™s the twist: which cells can flow into both oceans at once?
Thatâ€™s todayâ€™s LeetCode POTD (#417 Pacific Atlantic Water Flow). Letâ€™s break it down ðŸ§µ
#LeetCode #DSA #100DaysOfCode

Tweet 2:
Setup:

Left & Top edges touch the Pacific ðŸŒŠ

Right & Bottom edges touch the Atlantic ðŸŒŠ

Water flows from a higher/equal cell â†’ to a lower/equal neighbor.

Question: Find all cells where rainwater can flow to both oceans.

Tweet 3:
At first glance, it feels like we need to simulate flow from each cell.
But that would be way too slow. ðŸ˜…
Instead, letâ€™s flip the perspective:
ðŸ‘‰ Instead of sending water out, let the oceans push inward.

Tweet 4:
Think of both oceans as armies ðŸŒŠ marching into the island.

Pacific starts from the top & left edges.

Atlantic starts from the bottom & right edges.
Rule: They can only march uphill or flat (to equal or higher cells).

Tweet 5:
So we run two BFS/DFS waves:
1ï¸âƒ£ One from Pacific edges â†’ mark all reachable cells.
2ï¸âƒ£ One from Atlantic edges â†’ mark all reachable cells.
The intersection = cells that can reach both oceans! âœ…

Tweet 6:
This approach is neat because:

We only start from the borders.

Each cell is visited at most twice.

We avoid brute-forcing from every cell.
â±ï¸ Time complexity ~ O(m*n).

Tweet 7 (Engagement):
In Example 1, cells like (0,4), (1,3), (3,0) can flow both ways.
In Example 2 (just 1 cell), that lone cell touches both oceans directly.
ðŸŒ§ï¸ Isnâ€™t it cool how flipping perspective makes the problem so much easier?

Tweet 8 (Closing):
So the key insight:
Donâ€™t simulate water leaving â†’ simulate oceans entering. ðŸŒŠ
This reversal turns a messy flow problem into a clean graph traversal.

Would you like me to post a similar step-by-step visual explanation for this? ðŸ‘€ðŸ“Š

#LeetCode #DSA #GraphTheory #Coding


---
```cpp

class Solution {
public:
    vector<vector<int>> dirs = {{-1,0},{1,0},{0,1},{0,-1}};
    
    void bfs(int X, int Y, vector<vector<int>>& heights, vector<vector<bool>>& vis) {
        queue<pair<int,int>> q;
        q.push({X,Y});
        vis[X][Y] = true;
        int n = heights.size(), m = heights[0].size();

        while(!q.empty()) {
            auto [x,y] = q.front(); q.pop();
            for(auto& d : dirs) {
                int nx = x + d[0], ny = y + d[1];
                if(nx>=0 && nx<n && ny>=0 && ny<m && !vis[nx][ny] && heights[nx][ny] >= heights[x][y]) {
                    vis[nx][ny] = true;
                    q.push({nx, ny});
                }
            }
        }
    }

    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        int n = heights.size(), m = heights[0].size();
        vector<vector<bool>> po(n, vector<bool>(m,false)), ao(n, vector<bool>(m,false));
        vector<vector<int>> res;

        for(int i=0; i<n; i++) {
            bfs(i, 0, heights, po);
            bfs(i, m-1, heights, ao);
        }
        for(int j=0; j<m; j++) {
            bfs(0, j, heights, po);
            bfs(n-1, j, heights, ao);
        }

        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                if(po[i][j] && ao[i][j]) res.push_back({i,j});
            }
        }
        return res;
    }
};


```

