# 120. Triangle
Given a triangle array, return the minimum path sum from top to bottom.

For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.

 

Example 1:

Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
Output: 11
Explanation: The triangle looks like:
   2
  3 4
 6 5 7
4 1 8 3
The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).
Example 2:

Input: triangle = [[-10]]
Output: -10
 

Constraints:

1 <= triangle.length <= 200
triangle[0].length == 1
triangle[i].length == triangle[i - 1].length + 1
-104 <= triangle[i][j] <= 104
 

Follow up: Could you do this using only O(n) extra space, where n is the total number of rows in the triangle?

---

1 (Hook):
Todayâ€™s LeetCode POTD â€“ Triangle ðŸ”º
A DP classic where we need to find the minimum path sum from top to bottom. Letâ€™s break it down simply ðŸ‘‡ #LeetCode #DSA

Tweet 2:
Weâ€™re given a triangle like:

   2  
  3 4  
 6 5 7  
4 1 8 3


From the top, you can move down to adjacent numbers only.
Our goal? Find the smallest possible sum.

Tweet 3:
ðŸ’¡ Intuition:
Instead of starting from the top (which has too many choices), start from the bottom.

At each step, decide:
ðŸ‘‰ â€œIf Iâ€™m here, whatâ€™s the minimum path I can take below me?â€

Tweet 4:
Work bottom-up:

Take the last row as the base.

Move upward, each element becomes:
value + min(leftDown, rightDown)

By the time we reach the top, thatâ€™s our answer âœ…

Tweet 5 (Engagement):
Why this works:

Weâ€™re reducing overlapping subproblems

No need for recursion or big memory

Just pure DP efficiency ðŸ’¯

Final answer for the example? 11

Tweet 6 (Closer):
This problem shows the power of thinking bottom-up in DP ðŸ”¥
Instead of building paths, we collapse choices into minimums.
---

```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        for (int i = n - 2; i >= 0; i--) {
            for (int j = 0; j < triangle[i].size(); j++) {
                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]);
            }
        }
        return triangle[0][0];
    }
};

```
